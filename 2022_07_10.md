`useEffect`
- 컴포넌트가 마운트 됐을 때 (처음 나타났을 때), 언마운트 됐을 때 (사라질 때), 그리고 업데이트 될 때 (특정 props가 바뀔 때) 특정 작업을 처리
- 컴포넌트의 내용이 업데이트되면 기존의 값을 언마운트하고 새로운 값을 마운트함
- 첫 번째 파라미터에는 함수, 두 번째 파라미터에는 의존값이 들어있는 배열 (deps) 넣기
- useEffect 안에서 사용하는 상태나 props 가 있다면, useEffect 의 deps 에 넣어주기 (useEffect가 최신 props / 상태를 가리키기 위함)
- useEffect 에서 함수를 return할 수 있음 -> cleanup 함수 (뒷정리)
#
**1. deps 가 빈배열**
```javascript
useEffect(() => { // 마운트
    console.log('컴포넌트가 화면에 나타남');
    return () => { // 언마운트
      console.log('컴포넌트가 화면에서 사라짐');
    };
  }, []);
```
- 컴포넌트가 처음 마운트될 때 useEffect 내 함수 호출 (componentDidmount)
- 컴포넌트가 언마운트될 때 cleanup 함수 호출 (componentWillUnmount)
#
**2. deps 에 의존 값 있음**
```javascript
useEffect(() => { // 마운트
    console.log('user 값이 설정됨');
    console.log(user);
    return () => { // 언마운트
      console.log('user 가 바뀌기 전..');
      console.log(user);
    };
  }, [user]);
```
- 컴포넌트가 처음 마운트될 때 useEffect 내 함수 호출 (componentDidmount)
- 의존 값이 업데이트 됐을 때 (componentDidUpdate)
- 컴포넌트가 언마운트될 때 cleanup 함수 호출 (componentWillUnmount)
#
**3. deps 파라미터 생략**
```javascript
useEffect(() => { // 마운트
    console.log(user);
  });
```
- 그냥 컴포넌트가 리렌더링될 때마다 함수 호출됨
#
- 리액트 컴포넌트는 기본적으로 부모 컴포넌트가 리렌더링되면 자식 컴포넌트 또한 리렌더링됨
- Virtual DOM 에 모두 렌더링 -> 바뀐 내용이 있는 컴포넌트만 실제 DOM 에 반영
***
`useMemo` (성능 최적화할 때)
- "memorized", 이전에 계산한 값을 재사용한다는 의미
- 첫 번째 파라미터에는 어떻게 연산할지 정의하는 함수를, 두 번째 파라미터에는 deps 배열을 넣기
- deps 배열 안에 넣은 내용이 바뀌면 함수 호출, 내용이 바뀌지 않으면 이전 값을 재사용
#
**useMemo 사용 전**: input 값을 바꿀 때에도 countActiveUsers 함수가 호출됨 (불필요할 때에도 호출하여서 자원 낭비)
```javascript
const countActiveUsers = () => {
    console.log('count active users..');
    return users.filter(user => user.active).length;
}

const count = countActiveUsers(users);
return (
    <>
      <CreateUser
        username={username}
        email={email}
        onChange={onChange}
        onCreate={onCreate}
      />
      <UserList users={users} onRemove={onRemove} onToggle={onToggle} />
      <div>활성사용자 수 : {count}</div>
    </>
  );
```
- ex) 이메일을 입력한다고 치면 CreateUser 컴포넌트의 email이라는 속성(props)가 바뀌게 되는데 이 값은 원래 App 컴포넌트의 state임
- 결국 input에 입력하는 행위는 App Component의 state를 바꾸게 되는 행위
- App의 state가 변경됐으니 App Component가 다시 렌더링되면서 countActiveUsers가 실행되면서 호출됨
#
**useMemo 사용**: users에 변화가 있을 때만 countActiveUsers 함수 호출해서 성능 최적화
```javascript
const countActiveUsers = () => {
    console.log('count active users..');
    return users.filter(user => user.active).length;
}

const count = useMemo(() => countActiveUsers(users), [users]);
  return (
    <>
      <CreateUser
        username={username}
        email={email}
        onChange={onChange}
        onCreate={onCreate}
      />
      <UserList users={users} onRemove={onRemove} onToggle={onToggle} />
      <div>활성사용자 수 : {count}</div>
    </>
  );
```
#
학습 사이트: https://react.vlpt.us/basic/17-useMemo.html

16. useEffect를 사용하여 마운트/언마운트/업데이트시 할 작업 설정하기  
17. useMemo 를 사용하여 연산한 값 재사용하기
