서버가 클라이언트 인증을 확인하는 대표적인 방식
- 쿠키
- 세션
- 토큰
이러한 방식들은 클라이언트와 서버의 웹 통신 정보와 상태를 기록하여, 다시 페이지에 접속했을 때 그대로 로그인 정보가 남아있기 하기 위한 용도로 사용된다.
***
### Cookie
- 클라이언트가 어떠한 웹사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버를 통해 **클라이언트의 브라우저에 설치되는 작은 기록 정보 파일**이다.
- key-value 형식의 문자열이다.
#
인증 방식은 다음과 같다.
- 브라우저(클라이언트)가 서버에 요청(접속)을 보낸다.
- 서버는 클라이언트의 요청에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 응답 헤더의 Set-Cookie에 담는다.
- 이후 해당 클라이언트는 요청을 보낼 때마다, 매번 저장된 쿠키를 요청 헤더의 Cookie에 담아 보낸다.  
서버는 쿠키에 담긴 정보를 바탕으로 해당 요청의 클라이언트가 누군지 식별하거나 정보를 바탕으로 추천 광고를 띄우거나 한다.
#
Cookie 방식의 단점
- 보안에 취약하다. (요청 시 쿠키의 값을 그대로 보내기 때문에 유출 및 조작의 위험이 있음)
- 쿠키에는 용량 제한이 있어 많은 정보를 담을 수 없다.
- 브라우저간 공유가 불가능하다. (웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 때문)
- 쿠키의 사이즈가 커질수록 네트워크에 부하가 심해진다.
***
### Session
- 비밀번호 등 클라이언트의 민감한 인증 정보를 브라우저가 아닌 **서버 측에 저장하고 관리**한다. (쿠키의 보안적인 이슈 개선)
- 세션 객체는 key에 해당하는 SESSION ID와 이에 대응하는 value로 구성되어 있다. value에는 세션 생성 시간, 마지막 접근 시간 및 userId 등이 Map 형태로 저장된다.
#
인증 방식은 다음과 같다.
- 유저가 웹사이트에서 로그인하면 세션이 서버 메모리(혹은 데이터베이스)상에 저장된다.  
이때, 세션을 식별하기 위한 Session Id를 기준으로 정보를 저장한다.
- 서버에서 **브라우저의 쿠키에다가 Session Id를 저장**한다.
- 쿠키에 정보가 담겨있기 때문에 브라우저는 해당 사이트에 대한 모든 Request에 Session Id를 쿠키에 담아 전송한다.
- 서버는 클라이언트가 보낸 Session Id와 서버 메모리로 관리하고 있는 Session Id를 비교하여 인증을 수행한다.
#
Session 방식의 단점
- 해커가 Session Id 자체를 탈취하여 클라이언트인 척 위장할 수 있다. (서버에서 IP 특정을 통해 해결할 수 있긴 함)
- 서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버에 부하가 심해진다.
***
### Token
- 클라이언트가 서버에 접속하면 서버에서 해당 클라이언트에게 인증되었다는 의미로 토큰을 부여한다.
- 이 토큰은 유일하며 토큰을 발급받은 클라이언트는 또 다시 서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서 보낸다.
- 그러면 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 일치 여부를 체크하여 인증 과정을 처리하게 된다.
#
기존의 세션기반 인증은 서버가 파일이나 데이터베이스에 세션정보를 가지고 있어야 하고 이를 조회하는 과정이 필요하기 때문에 많은 오버헤드가 발생한다.  
하지만 토큰은 세션과는 달리 서버가 아닌 **클라이언트에 저장**된다. 때문에 서버의 부담을 덜 수 있다.  
토큰 자체에 데이터가 들어있기 때문에 클라이언트에서 받아 위조되었는지 판별만 하면 된다.  
웹과 달리 앱에서는 쿠키와 세션이 없기 때문에 앱과 서버가 통신 및 인증할 때 토큰이 가장 많이 사용된다.
#
인증 방식은 다음과 같다.
- 사용자가 아이디와 비밀번호로 로그인한다.
- 서버 측에서 사용자(클라이언트)에게 **유일한 토큰**을 발급한다.
- 클라이언트는 서버 측에서 전달받은 토큰을 쿠키나 스토리지에 저장해 두고, 서버에 요청을 할 때마다 해당 토큰을 요청 헤더에 포함시켜 전달한다.
- 서버는 전달받은 토큰을 검증하고 요청에 응답한다.  
토큰에는 요청한 사람의 정보가 담겨있기에 서버는 DB를 조회하지 않고 누가 요청하는지 알 수 있다.
#
Token 방식의 단점
- 쿠키/세션과 다르게 토큰 자체의 데이터 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해질 수 있다.
- 유저의 중요한 정보는 담을 수 없다. (Payload 자체는 암호화되지 않기 때문)
- 토큰을 탈취당하면 대처하기 어렵다. (사용 기간 제한을 설정하는 식으로 극복할 수 있음)
***
쿠키와 세션은 정보의 저장 위치가 다르다.  
쿠키는 클라이언트의 인증 정보가 클라이언트의 브라우저에 저장되는 반면, 세션은 서버 측에서 저장되고 관리된다.  
때문에 쿠키는 보안에 취약하다는 이슈를 가지며, 세션은 이러한 문제를 개선한다. 하지만 세션은 요청이 많아질 경우 서버의 부하가 심해진다는 단점이 있다.  
한편, 쿠키와 세션은 별도의 저장소 관리가 필요하다. 하지만 토큰은 발급한 후 검증만 하면 되기 때문에 추가 저장소가 필요하지 않다.  
또한 토큰은 토큰을 기반으로 하는 다른 인증 시스템(ex. facebook, google, ...)에 접근이 가능하기 때문에 확장성이 뛰어나다는 장점이 있다.
단점으로는 토큰 자체의 데이터 길이가 길기 때문에 인증 요청이 많아질수록 네트워크 부하가 심해진다는 점이다.
#
출처: [여기](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)랑 [여기](https://brunch.co.kr/@b30afb04c9f54dc/7)
