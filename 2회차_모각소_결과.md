리액트에서 배열이나 객체를 업데이트해야 할 때에는 **불변성을 지켜주면서 업데이트**를 해주어야 함
```javascript
/* 이렇게 하면 안 됨 */
const object = {
  a: 1,
  b: 2
};

object.b = 3;

/* 이렇게 해야 함 */
const object = {
  a: 1,
  b: 2
};

const nextObject = {
  ...object,
  b: 3
};
```
- `... 연산자`를 사용해서 새로운 객체를 만든 후에 수정
#
배열의 경우 `push`, `splice` 등의 함수를 사용하거나 n 번째 항목을 직접 수정하면 안되고,  
아래처럼 `concat`, `filter`, `map` 등의 함수를 사용해야 함
```javascript
const todos = [
  {
    id: 1,
    text: '할 일 #1',
    done: true
  },
  {
    id: 2
    text: '할 일 #2',
    done: false
  }
];

const inserted = todos.concat({
  id: 3,
  text: '할 일 #3',
  done: false
});

const filtered = todos.filter(todo => todo.id !== 2);

const toggled = todos.map(
  todo => todo.id === 2
    ? {
      ...todo,
      done: !todo.done,
    }
    : todo
);
```
#
ex) 아래와 같은 객체가 있음
```javascript
const state = {
  posts: [
    {
      id: 1,
      title: '제목입니다.',
      body: '내용입니다.',
      comments: [
        {
          id: 1,
          text: '와 정말 잘 읽었습니다.'
        }
      ]
    },
    {
      id: 2,
      title: '제목입니다.',
      body: '내용입니다.',
      comments: [
        {
          id: 2,
          text: '또 다른 댓글 어쩌고 저쩌고'
        }
      ]
    }
  ],
  selectedId: 1
};
```
여기서 posts 배열 안의 id 가 1 인 post 객체를 찾아서, comments 에 새로운 댓글 객체를 추가하려면 아래처럼 해주어야 함
```javascript
const nextState = {
  ...state,
  posts: state.posts.map(post =>
    post.id === 1
      ? {
          ...post,
          comments: post.comments.concat({
            id: 3,
            text: '새로운 댓글'
          })
        }
      : post
  )
};
```
- 코드의 구조가 좀 복잡해서 한 눈에 들어오질 않음 -> `immer` 라는 라이브러리를 사용하면 코드가 훨씬 깔끔해지고 잘 읽힘
```javascript
const nextState = produce(state, draft => {
  const post = draft.posts.find(post => post.id === 1);
  post.comments.push({
    id: 3,
    text: '와 정말 쉽다!'
  });
});
```
- `Immer` 를 사용하면 우리가 상태를 업데이트 할 때, 불변성을 신경쓰지 않으면서 업데이트를 해줄 수 있음
- `Immer` 가 불변성 관리를 대신 해주기 때문
#
## Immer 사용법
- `$ yarn add immer` : immer 설치
- `import produce from 'immer';` : 코드의 상단에서 immer 를 불러와야 함. 보통 produce 라는 이름으로 불러옴
- produce 함수 사용 시 첫 번째 파라미터에는 수정하고 싶은 상태, 두 번째 파라미터에는 어떻게 업데이트할지 정의하는 함수를 넣어줌 (불변성에 대해서 신경쓰지 않아도 됨)
```javascript
const state = {
  number: 1,
  dontChangeMe: 2
};

const nextState = produce(state, draft => {
  draft.number += 1;
});

console.log(nextState);
// { number: 2, dontChangeMe: 2 }
```
***
## 리듀서에서 Immer 사용하기
- `Immer` 를 사용해서 간단해지는 업데이트가 있는 반면 오히려 코드가 길어지는 업데이트가 있음
- ex) users 배열은 객체의 깊은 곳에 위치하지 않음
- 때문에 새 항목을 추가하거나 제거할 때는 `Immer` 를 사용하는 것보다 `concat` 과 `filter` 를 사용하는 것이 더 코드가 짧고 편함
#
**Immer 사용 전**
```javascript
import React, { useReducer, useMemo } from 'react';
import UserList from './UserList';
import CreateUser from './CreateUser';

function countActiveUsers(users) {
  console.log('활성 사용자 수를 세는중...');
  return users.filter(user => user.active).length;
}

const initialState = {
  users: [
    {
      id: 1,
      username: 'velopert',
      email: 'public.velopert@gmail.com',
      active: true
    },
    {
      id: 2,
      username: 'tester',
      email: 'tester@example.com',
      active: false
    },
    {
      id: 3,
      username: 'liz',
      email: 'liz@example.com',
      active: false
    }
  ]
};

function reducer(state, action) {
  switch (action.type) {
    case 'CREATE_USER':
      return {
        users: state.users.concat(action.user)
      };
    case 'TOGGLE_USER':
      return {
        ...state,
        users: state.users.map(user =>
          user.id === action.id ? { ...user, active: !user.active } : user
        )
      };
    case 'REMOVE_USER':
      return {
        ...state,
        users: state.users.filter(user => user.id !== action.id)
      };
    default:
      return state;
  }
}

// UserDispatch 라는 이름으로 내보내줍니다.
export const UserDispatch = React.createContext(null);

function App() {
  const [state, dispatch] = useReducer(reducer, initialState);

  const { users } = state;

  const count = useMemo(() => countActiveUsers(users), [users]);
  return (
    <UserDispatch.Provider value={dispatch}>
      <CreateUser />
      <UserList users={users} />
      <div>활성사용자 수 : {count}</div>
    </UserDispatch.Provider>
  );
}

export default App;
```
#
**Immer 사용**
```javascript
import React, { useReducer, useMemo } from 'react';
import UserList from './UserList';
import CreateUser from './CreateUser';
import produce from 'immer';

function countActiveUsers(users) {
  console.log('활성 사용자 수를 세는중...');
  return users.filter(user => user.active).length;
}

const initialState = {
  users: [
    {
      id: 1,
      username: 'velopert',
      email: 'public.velopert@gmail.com',
      active: true
    },
    {
      id: 2,
      username: 'tester',
      email: 'tester@example.com',
      active: false
    },
    {
      id: 3,
      username: 'liz',
      email: 'liz@example.com',
      active: false
    }
  ]
};

function reducer(state, action) {
  switch (action.type) {
    case 'CREATE_USER':
      return produce(state, draft => {
        draft.users.push(action.user);
      });
    case 'TOGGLE_USER':
      return produce(state, draft => {
        const user = draft.users.find(user => user.id === action.id);
        user.active = !user.active;
      });
    case 'REMOVE_USER':
      return produce(state, draft => {
        const index = draft.users.findIndex(user => user.id === action.id);
        draft.users.splice(index, 1);
      });
    default:
      return state;
  }
}

// UserDispatch 라는 이름으로 내보내줍니다.
export const UserDispatch = React.createContext(null);

function App() {
  const [state, dispatch] = useReducer(reducer, initialState);

  const { users } = state;

  const count = useMemo(() => countActiveUsers(users), [users]);
  return (
    <UserDispatch.Provider value={dispatch}>
      <CreateUser />
      <UserList users={users} />
      <div>활성사용자 수 : {count}</div>
    </UserDispatch.Provider>
  );
}

export default App;
```
- TOGGLE_USER 액션의 경우 `Immer` 를 사용하니 코드가 깔끔해졌는데, 나머지의 경우 오히려 코드가 좀 복잡해졌음
- 상황에 따라 잘 선택하여 사용할 것
#
**Immer 와 함수형 업데이트**
```javascript
const [todo, setTodo] = useState({
  text: 'Hello',
  done: false
});

const onClick = useCallback(() => {
  setTodo(todo => ({
    ...todo,
    done: !todo.done
  }));
}, []);
```
- setTodo 함수에 업데이트를 해주는 함수를 넣음으로써, `useCallback` 을 사용하는 경우 두 번째 파라미터인 deps 배열에 todo 를 넣지 않아도 되었음
이렇게 함수형 업데이트를 하는 경우에, 아래처럼 `Immer` 를 사용하면 상황에 따라 더 편하게 코드 작성 가능
```javascript
const todo = {
  text: 'Hello',
  done: false
};

const updater = produce(draft => {
  draft.done = !draft.done;
});

const nextTodo = updater(todo);

console.log(nextTodo);
// { text: 'Hello', done: true }
```
- **produce 함수에 파라미터 두 개 넣기** : 첫 번째 파라미터에 넣은 상태에 대해 불변성을 유지하면서 새로운 상태를 만들어줌
- **produce 함수에 첫 번째 파라미터를 생략하고 바로 업데이트 함수를 넣기** : 반환 값은 새로운 상태가 아닌, 상태를 업데이트해주는 함수가 됨
`useState` 의 업데이트 함수를 사용할 때 아래처럼 구현 가능
```javascript
const [todo, setTodo] = useState({
  text: 'Hello',
  done: false
});

const onClick = useCallback(() => {
  setTodo(
    produce(draft => {
      draft.done = !draft.done;
    })
  );
}, []);
```
#
- `Immer` 은 데이터의 구조가 복잡해져서 불변성을 유지하면서 업데이트하기에 코드가 복잡해지는 상황이 오는 경우 사용하기 편한 라이브러리임
- 하지만, 성능적으로는 `Immer` 를 사용하지 않은 코드가 조금 더 빠름. 따라서 필요한 곳에만 쓰고, 간단히 처리될 수 있는 곳에서는 그냥 일반 JavaScript 로 구현할 것
***
## 클래스형 컴포넌트
- 이제는 잘 사용하지 않지만, 옛날에 만들어진 걸 유지보수할 일이 생길 경우를 대비하여 알아 두면 좋을 듯
```javascript
/* 함수형 컴포넌트 */
import React from 'react';

function Hello({ color, name, isSpecial }) {
  return (
    <div style={{ color }}>
      {isSpecial && <b>*</b>}
      안녕하세요 {name}
    </div>
  );
}

Hello.defaultProps = {
  name: '이름없음'
};

export default Hello;

/* 클래스형 컴포넌트 */
import React, { Component } from 'react';

class Hello extends Component {
  static defaultProps = {
    name: '이름없음'
  };
  render() {
    const { color, name, isSpecial } = this.props;
    return (
      <div style={{ color }}>
        {isSpecial && <b>*</b>}
        안녕하세요 {name}
      </div>
    );
  }
}

export default Hello;
```
- 클래스형 컴포넌트에서는 `render()` 메서드가 있고, 이 메서드에서 렌더링하고 싶은 JSX 를 반환
- props 를 조회해야 할 때에는 this.props 를 조회
- defaultProps 설정 시 함수형 컴포넌트에서 했을 때와 똑같이 해도 되고, 클래스 내부에 static 키워드와 함께 선언할 수도 있음
***
## LifeCycle Method
- 생명주기 메서드는 컴포넌트가 브라우저상에 나타나고, 업데이트되고, 사라지게 될 때 호출되는 메서드들임
- 추가적으로 컴포넌트에서 에러가 났을 때 호출되는 메서드도 있음
- 생명주기 메서드는 클래스형 컴포넌트에서만 사용 가능
- `useEffect` 랑 은근히 비슷 (작동방식은 많이 다르고, 커버하지 않는 기능들도 있음)
- 나중에 사용해야 할 일이 있다면 [매뉴얼](https://ko.reactjs.org/docs/react-component.html)을 보고 사용할 수 있는 정도만 학습할 것
